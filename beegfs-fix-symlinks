#!/usr/bin/env python3

import os, sys, stat, pwd, argparse, re, datetime
from pathlib import Path


args = None
maxpath = 512
ns = 1000000000
uids = {}


def parse_args():
    global args
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--output")
    parser.add_argument("-d", "--original-dir", default="/mercury/data2")
    parser.add_argument("-O", "--chown", action="store_true")
    parser.add_argument("dir", nargs="*")
    args = parser.parse_args()


def quote(val):
    """Quote/escape a string in a safe way for Bourne-style shells."""
    if (
        val == ""
        or re.search(r"[][(){}<>;&|*?^!$`'\\\"\0- \x7F-\xFF]", val)
        or val[0] == "~"
        or re.search(r"[:=]~", val)
    ):
        return '"' + re.sub(r'([\\$"`])', r"\\\1", val) + '"'
    return val


def is_symlink(fpath):
    try:
        st = fpath.stat()
    except OSError:
        return None
    size = st.st_size
    if not (size and size <= maxpath):
        return None
    try:
        with open(fpath, encoding="latin-1") as f:
            cont = f.read()
    except OSError:
        return None
    if re.search(r"[\n\0]", cont):  # no \n at end!
        return None
    if re.search(
        r"^(/cvmfs/|\.\./|"
        + args.original_dir
        + r"/)[^][(){}<>;&|*?^!$`'\\\"\0- \x7F-\xFF]+$",
        cont,
    ):
        return cont, st
    pcont = Path(cont)
    target = fpath.parent / pcont
    try:
        exists = target.is_symlink() or target.exists()
    except OSError:
        exists = False
    if exists:
        return cont, st
    if pcont.is_absolute():
        return None
    for d in target.parents:
        try:
            isdir = d.is_dir()
        except OSError:
            isdir = False
        if isdir:
            return None  # the parent directory exists, so a recovered symlink can't explain why the target doesn't exist
        if is_symlink(d):
            return cont, st
    return None


def modtime(st):
    t = st.st_mtime_ns
    return "{}.{:09d}".format(
        datetime.datetime.fromtimestamp(t // ns).isoformat(), t % ns
    )


def uid(fpath, st):
    if fpath.is_symlink():
        um = re.search(r"/storage/chunks/u([\da-fA-F]+)/", os.readlink(str(fpath)))
        if um:
            uid = int(um.groups()[0], 16)
            ugid = uids.get(uid)
            if ugid is not None:
                return ugid
            try:
                gid = pwd.getpwuid(uid).pw_gid
                ugid = f"{uid}:{gid}"
            except KeyError:
                ugid = str(uid)
            uids[uid] = ugid
            return ugid
    return f"{st.st_uid}:{st.st_gid}"


def process():
    global maxpath
    parse_args()

    if args.output is not None:
        out = open(args.output, "w")
        os.chmod(
            out.fileno(),
            os.stat(out.fileno()).st_mode
            | (stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH),
        )
    else:
        out = sys.stdout

    print("#!/bin/bash", file=out)
    print("set -x", file=out)

    for d in args.dir if args.dir else [""]:
        idir = Path(d)
        maxpath = os.pathconf(idir, "PC_PATH_MAX")
        for root, dirs, files in os.walk(idir):
            proot = Path(root)
            for name in files:
                fpath = proot / name
                cs = is_symlink(fpath)
                if cs:
                    cont, st = cs
                    lnk = quote(str(fpath))
                    print("ln -nfs", quote(cont), lnk, file=out)
                    if args.chown:
                        print("chown -h", uid(fpath, st), lnk, file=out)
                    print("touch -hd", modtime(st), lnk, file=out)

    if args.output is not None:
        out.close()

    return 0


exit(process())
