#!/usr/bin/env python3

import sys, os, stat, argparse, re, itertools, collections
from collections import defaultdict, namedtuple
from pathlib import Path

Dir = namedtuple(
    "Dir", ["name", "tag", "metas", "nosub", "parent"]
)  # defaults=["", "", [], False]  # py3.7
File = namedtuple(
    "File", ["dir", "name", "tags", "chunks", "empty", "metas"]
)  # defaults=[Dir(), "", [], [], False, []] # py3.7
Chunk = namedtuple("Chunk", ["tag", "meta", "stors"])  # defaults=["", "", []]  # py3.7

args = None


def parse_args():
    global args
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-f", "--list-files", action="store_true")
    parser.add_argument("-d", "--list-directories", action="store_true")
    parser.add_argument("-c", "--list-chunks", action="store_true")
    parser.add_argument("-s", "--script", action="store_true")
    parser.add_argument("-e", "--empty-directories", action="store_true")
    parser.add_argument("-m", "--missing-chunks", action="store_true")
    parser.add_argument("-t", "--tags", action="store_true")
    parser.add_argument("-M", "--metadata", action="store_true")
    parser.add_argument("-n", "--max-files", type=int)
    parser.add_argument("-u", "--user", default="")
    parser.add_argument("-o", "--output")
    parser.add_argument("-C", "--command", default="cp -n --preserve=timestamps")
    parser.add_argument("-D", "--dest-dir", default="")
    parser.add_argument("dir", nargs="?", default="")
    args = parser.parse_args()


def err(*fargs, **fkwargs):
    if args.quiet:
        return
    print(*fargs, file=sys.stderr, **fkwargs)


def info(*fargs, **fkwargs):
    if not args.verbose:
        return
    print(*fargs, file=sys.stderr, **fkwargs)


def quote(val):
    """Quote/escape a string in a safe way for Bourne-style shells."""
    if (
        val == ""
        or re.search(r"[][(){}<>;&|*?^!$`'\\\"\s]", val)
        or val[0] == "~"
        or re.search(r"[:=]~", val)
    ):
        return '"' + re.sub(r'([\\$"`])', r"\\\1", val) + '"'
    return val


def dirfile(dir, file):
    if dir:
        return f"{dir}/{file}"
    else:
        return file


def nodup(lst, key=None):
    if key is None:
        return {e: None for e in lst}.keys()
    else:
        dup = {}
        for e in lst:
            dup.setdefault(key(e), e)
        return dup.values()


def uextend(lst, ext, key=None):
    if key is None:
        for e in ext:
            if e not in lst:
                lst.append(e)
    else:
        k = [key(l) for l in lst]
        for e in ext:
            if key(e) not in k:
                lst.append(e)
                k.append(key(e))


def lsdirs(index):
    def lsdir(name, tag, metas, parent=None, select="", top=None, depth=0):
        subs = tags.get(tag)
        if subs is None:
            if (name + "/").startswith(select):
                return [Dir(name=name, tag=tag, metas=metas, parent=parent, nosub=True)]
            else:
                return []
        named = name + ("/" if name else "")
        if depth > 100:
            if (name + "/").startswith(select):
                err("directory too deep:", name)
                return [
                    Dir(
                        name=name + "...",
                        tag=tag,
                        metas=metas,
                        parent=parent,
                        nosub=True,
                    )
                ]
            else:
                return []
        else:
            this = Dir(name=name, tag=tag, metas=metas, parent=parent, nosub=False)
            if (name + "/").startswith(select):
                dirs = [this]
            else:
                dirs = []
            tsubs = defaultdict(list)
            dsubs = defaultdict(list)
            for s in subs:
                if top is not None and s.name == top:
                    metas.extend(s.metas)
                    continue
                tsub = tsubs.setdefault((s.name, s.tag), [])
                tsub.extend(s.metas)
                if len(tsub) == 1:
                    dirs += lsdir(
                        name=named + s.name,
                        tag=s.tag,
                        metas=tsub,
                        parent=this,
                        select=select,
                        depth=depth + 1,
                    )
                dsubs[s.name].append(s.metas)
            for (d, t), mm in tsubs.items():
                if len(mm) > 1:
                    info(f"directory {named}{d} has multiple metadata:", " ".join(mm))
                dsubs.pop(d, None)
            for d, mm in dsubs.items():
                if len(mm) > 1:
                    err(f"directory {named}{d} has multiple tags:", " ".join(mm))
            return dirs

    tags = defaultdict(list)
    with open(index, encoding="latin-1") as fin:
        n = 0
        lines = []
        joined = None
        for l in fin:
            n += 1
            line = l.rstrip("\n")
            if line == "" or " " in line or "/" in line or n <= 1:
                if joined is not None:
                    info(joined)
                    joined = None
                if line != "":
                    lines.append([line, n])
            else:
                last = lines[-1]
                if joined is None:
                    lastl, lastn = last
                    joined = f"{index}:{lastn}: lines joined: {lastl}"
                joined += f"\\n {line}"
                last[0] += "\n" + line
        if joined is not None:
            info(joined)

        for line, n in lines:
            flds = line.split(" ", 1)
            if not (len(flds) == 2 and "/" not in flds[0] and "/" in flds[-1]):
                err(f"{index}:{n}: bad format:", re.sub(r"\n", " ", line))
                continue
            tag, meta = flds
            meta = re.sub(r"\n", " ", meta)
            stag, sdir = meta.split("/")[-2:]
            tags[stag].append(
                Dir(name=sdir, tag=tag, metas=[meta], parent=None, nosub=False)
            )

    dirs = lsdir(
        name="",
        tag="root",
        metas=[],
        top="root",
        select=args.user + "/" if args.user else "",
    )
    return nodup(dirs, lambda d: (d.name, d.tag))  # unique tag/dir


def lsfiles2(index, dirs):
    dtag = defaultdict(list)
    dlen = {}
    for d in dirs:
        dlen[d.tag] = 0
        dtag[d.tag].append(d)
    for t, dd in dtag.items():
        if len(dd) != 1:
            err(f"multiple dirs for tag {t}:", " ".join([d.name for d in dd]))

    chunks = defaultdict(list)

    files = []
    with open(index, encoding="latin-1") as fin:
        n = 0
        for l in fin:
            n += 1
            if args.max_files is not None and n > args.max_files:
                break
            w = l.rstrip("\n").split(" ", 1)
            if not (len(w) == 2 and w[0].isdigit() and "/" in w[1]):
                err(f"{index}:{n}: bad format:", line)
                continue
            tag, meta = w
            ftag, fname = meta.split("/")[-2:]
            if ftag == "#fSiDs#":
                chunks[tag].append(Chunk(tag=fname, meta=meta, stors=[]))
            else:
                dd = dtag.get(ftag)
                if dd is not None:
                    dlen[ftag] += len(dd)
                    i = meta.rfind("/")
                    xmeta = meta[:i] if i >= 0 else meta
                    for d in dd:
                        files.append(
                            File(
                                dir=d,
                                name=fname,
                                tags=[tag],
                                chunks=chunks.setdefault(tag, []),
                                empty=False,
                                metas=[xmeta],
                            )
                        )

    if args.empty_directories:
        for t, n in dlen.items():
            if n > 0:
                dd = dtag.get(t)
                for d in dd:
                    if d.nosub:
                        files.append(
                            File(
                                dir=d,
                                name="",
                                tags=[d.tag],
                                chunks=[],
                                empty=True,
                                metas=d.metas,
                            )
                        )
                        info("empty dir:", d.name)

    return files


# put duplicate check in a separate function to reduce memory usage
def lsfiles(index, dirs):
    files = lsfiles2(index, dirs)
    dfiles = {}
    ufiles = []
    for f in files:
        df = dirfile(f.dir.name, f.name)
        last = dfiles.get(df)
        if last is None:
            ufiles.append(f)
            dfiles[df] = f
        else:
            uextend(last.tags, f.tags)
            uextend(last.metas, f.metas)
            uextend(last.chunks, f.chunks, lambda c: c.tag)
    for f in ufiles:
        if len(f.tags) > 1:
            err(
                "file",
                dirfile(f.dir.name, f.name),
                "has multiple tags:",
                " ".join(f.tags) + ", chunks:",
                " ".join(nodup((c.tag for c in f.chunks))),
            )
    return ufiles


def lschunks(index, files):
    ctags = defaultdict(list)
    empty = []
    for f in files:
        if len(f.chunks) == 0:
            empty.append(f)
            if f.name != "":
                info("empty file:", dirfile(f.dir.name, f.name))
        for c in f.chunks:
            # if len(f.chunks)>1, each element gets the same f so we can update the appropriate bit for each chunk
            ctags[c.tag].append(f)

    for t, ff in ctags.items():
        if len(ff) > 1:
            err(
                f"chunk {t} used in multiple files:",
                " ".join(f.dir.name + "/" + f.name for f in ff),
            )
            # uff = nodup(f.dir.name + "/" + f.name for f in ff)
            # if len(uff) > 1:
            # err(f"chunk {t} used in multiple files:", " ".join(uff))

    cfiles = []
    with open(index, encoding="latin-1") as fin:
        n = 0
        for l in fin:
            n += 1
            chunk = l.rstrip("\n")
            if " " in chunk or "/" not in chunk:
                err(f"{index}:{n}: bad format:", chunk)
                continue
            ctag = chunk.split("/")[-1]
            ff = ctags.get(ctag)
            if ff is not None:
                for f in ff:
                    n = 0
                    for c in f.chunks:
                        n += len(c.stors)
                        if c.tag == ctag:  # should always match exactly once
                            c.stors.append(chunk)
                    if n == 0:
                        # Only append the first time we see a chunk in this file. Other chunks will be added later.
                        cfiles.append(f)

    for t, ff in ctags.items():
        for f in ff:
            n = 0
            if len(f.chunks) > 1:
                err(
                    "multiple chunks for file",
                    dirfile(f.dir.name, f.name) + ":",
                    " ".join([c.tag for c in f.chunks]),
                )
            for c in f.chunks:
                n += len(c.stors)
                if len(c.stors) == 0:
                    err("file", dirfile(f.dir.name, f.name), f"chunk {c.tag} not found")
                elif len(c.stors) > 1:
                    info(
                        "multiple storage instances for file",
                        dirfile(f.dir.name, f.name),
                        f"chunk {c.tag}:",
                        " ".join(c.stors),
                    )
            if n == 0 and args.missing_chunks:
                cfiles.append(f)

    cfiles += empty

    return cfiles


def process():
    parse_args()
    idir = Path(args.dir)
    dirs = lsdirs(idir / "dir-metadata-index.txt")
    dest = Path(args.dest_dir)

    if args.output is not None:
        out = open(args.output, "w")
        if args.script:
            os.chmod(
                out.fileno(),
                os.stat(out.fileno()).st_mode
                | (stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH),
            )
    else:
        out = sys.stdout

    if args.list_directories:
        for d in nodup(dirs, lambda d: d.name):
            print(
                d.name
                + ("\t" + d.tag if args.tags else "")
                + ("\t" + " ".join(d.metas) if args.metadata else ""),
                file=out,
            )

    if args.list_files:
        files = lsfiles(idir / "file-metadata-index.txt", dirs)
        for f in nodup(files, lambda f: (f.dir.name, f.name)):
            print(
                dirfile(f.dir.name, f.name)
                + ("\t" + " ".join(f.tags) if args.tags else "")
                + ("\t" + " ".join(f.metas) if args.metadata else ""),
                file=out,
            )

    if args.list_chunks:
        cfiles = lschunks(
            idir / "storage-chunk-index.txt",
            lsfiles(idir / "file-metadata-index.txt", dirs),
        )
        for f in nodup(
            cfiles,
            lambda f: (
                f.dir.name,
                f.name,
                tuple(nodup((s for c in f.chunks for s in c.stors))),
            ),
        ):
            print(
                str(dest / dirfile(f.dir.name, f.name))
                + (
                    "\t" + " ".join(nodup((c.tag for c in f.chunks)))
                    if args.tags
                    else ""
                )
                + (
                    "\t" + " ".join(nodup(c.meta for c in f.chunks))
                    if args.metadata
                    else ""
                )
                + "\t"
                + " ".join(
                    (
                        str(idir / s)
                        for s in nodup((s for c in f.chunks for s in c.stors))
                    )
                ),
                file=out,
            )

    if args.script:
        cfiles = lschunks(
            idir / "storage-chunk-index.txt",
            lsfiles(idir / "file-metadata-index.txt", dirs),
        )

        udirs = {f.dir.name: f.dir for f in cfiles}
        # remove redundent mkdir -p
        for d in list(udirs.values()):
            while d.parent:
                d = d.parent
                if d.name in udirs:
                    udirs.pop(d.name, None)

        print("#!/bin/bash", file=out)
        print("set -x", file=out)
        for d in udirs.keys():
            print("mkdir -p", quote(str(dest / d)), file=out)
        del udirs

        links = []
        for f in cfiles:
            needsuf = sum([len(c.stors) for c in f.chunks]) > 1
            needsuf = len(f.chunks) > 1 or sum([len(c.stors) for c in f.chunks]) > 1
            for c in f.chunks:
                if c.stors:
                    for s in c.stors:
                        links.append((dirfile(f.dir.name, f.name), s, needsuf))
                else:
                    links.append((dirfile(f.dir.name, f.name), c.meta, needsuf))

        for df, s, needsuf in nodup(links):
            print(
                args.command,
                quote(str(idir / s)),
                quote(str(dest / (df + ("." + s.split("/")[0] if needsuf else "")))),
                file=out,
            )
        del links

        # find all needed dirs and their parents
        udirs = {}
        for f in cfiles:
            d = f.dir
            udirs.setdefault(d.name, d)
            while d.parent:
                d = d.parent
                udirs.setdefault(d.name, d)

        for d in udirs.values():
            if len(d.metas) == 1:
                print(
                    "touch -r",
                    quote(str(idir / d.metas[0])),
                    quote(str(dest / d.name)),
                    file=out,
                )
            elif len(d.metas) > 1:
                print(
                    "touch -r $(ls -1dt",
                    " ".join([quote(str(idir / m)) for m in d.metas]),
                    "| head -1)",
                    quote(str(dest / d.name)),
                    file=out,
                )

    if args.output is not None:
        out.close()


exit(process())
