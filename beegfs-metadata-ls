#!/usr/bin/env python3

import sys, argparse, re
from collections import defaultdict
from pathlib import Path

args = None


def parse_args():
    global args
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-f", "--list-files", action="store_true")
    parser.add_argument("-d", "--list-directories", action="store_true")
    parser.add_argument("-c", "--list-chunks", action="store_true")
    parser.add_argument("-e", "--empty-directories", action="store_true")
    parser.add_argument("-m", "--missing-chunks", action="store_true")
    parser.add_argument("-t", "--tags", action="store_true")
    parser.add_argument("-n", "--max-files", type=int)
    parser.add_argument("-u", "--user", default="")
    parser.add_argument("dir", nargs="?", default=".")
    args = parser.parse_args()


def err(*fargs, **fkwargs):
    if args.quiet:
        return
    print(*fargs, file=sys.stderr, **fkwargs)


def info(*fargs, **fkwargs):
    if not args.verbose:
        return
    print(*fargs, file=sys.stderr, **fkwargs)


def lsdirs(index):
    def lsdir(tag, pre, depth=0):
        subs = tags.get(tag)
        if subs is None:
            return [(pre, tag)]
        if pre != "":
            pre += "/"
        if depth > 100:
            err("directory too deep:", pre)
            return [(pre + "...", tag)]
        else:
            dirs = []
            for t, f in subs:
                dirs += lsdir(t, pre + f)
            return dirs

    tags = defaultdict(list)
    toptags = {}
    with open(index, encoding="latin-1") as f:
        n = 0
        lines = []
        joined = None
        for l in f:
            n += 1
            line = l.rstrip("\n")
            if line == "" or " " in line or "/" in line or n <= 1:
                if joined is not None:
                    info(joined)
                    joined = None
                if line != "":
                    lines.append([line, n])
            else:
                last = lines[-1]
                if joined is None:
                    lastl, lastn = last
                    joined = f"{index}:{lastn}: lines joined: {lastl}"
                joined += f"\\n {line}"
                last[0] += "\n" + line
        if joined is not None:
            info(joined)

        for line, n in lines:
            flds = line.split(" ", 1)
            if not (len(flds) == 2 and "/" not in flds[0] and "/" in flds[-1]):
                err(f"{index}:{n}: bad format:", re.sub(r"\n", " ", line))
                continue
            tag, ent = flds
            ent = re.sub(r"\n", " ", line)
            stag, sdir = ent.split("/")[-2:]
            tags[stag].append([tag, sdir])

    dirs = []
    if args.user == "":
        dirs += lsdir("root", "")
    else:
        td = tags.get("root")
        if td is None:
            err(f"{index}: root directory not found")
        else:
            n = 0
            for t, d in td:
                if d == args.user:
                    n += 1
                    dirs += lsdir(t, d)
            if n == 0:
                err(f"{index}: root directory not found:", args.user)

    # return list(set(dirs))   # nt so good - reorders the list
    return {dt: 0 for dt in dirs}.keys()  # unique tag/dir


def lsfiles(index, dirs):
    dtag = defaultdict(list)
    dlen = {}
    for dt in dirs:
        dlen[dt[1]] = 0
        dtag[dt[1]].append(dt)
    for t, dt in dtag.items():
        if len(dt) != 1:
            err(f"multiple dirs for tag {t}:", " ".join([d[0] for d in dt]))

    chunks = defaultdict(list)
    max_files = args.max_files
    if max_files is None:
        max_files = -1

    files = []
    with open(index, encoding="latin-1") as f:
        n = 0
        for l in f:
            n += 1
            if max_files >= 0 and n > max_files:
                break
            w = l.rstrip("\n").split(" ", 1)
            if not (len(w) == 2 and w[0].isdigit() and "/" in w[1]):
                err(f"{index}:{n}: bad format:", line)
                continue
            tag, ent = w
            ftag, fname = ent.split("/")[-2:]
            if ftag == "#fSiDs#":
                chunks[tag].append(fname)
            else:
                dt = dtag.get(ftag)
                if dt is not None:
                    dlen[ftag] += 1
                    files.append([dt, fname, tag, chunks.setdefault(tag, []), False])

    if args.empty_directories:
        for t, n in dlen.items():
            if n != 0:
                continue
            dt = dtag.get(t)
            files.append([dt, "", "", [], True])
            for d, _ in dt:
                info("empty dir:", d)

    return files


def lschunks(index, files):
    ctags = defaultdict(list)
    empty = []
    for ff in files:
        dt, fname, t, ct, e = ff
        ffc = [ff, [[]] * len(ct)]
        if len(ct) == 0:
            empty.append([ffc])
            if fname != "":
                info("empty file:", " ".join([d + "/" + fname for d, _ in dt]))
            continue
        for c in ct:
            # if len(ct)>1, each element gets the same ffc so we can update the appropriate bit for each chunk
            ctags[c].append(ffc)

    for t, ffc in ctags.items():
        if len(ffc) > 1 or len(ffc[0][0][0]) > 1:
            err(
                f"chunk {t} used in multiple files:",
                " ".join([d + "/" + ff[0][1] for ff in ffc for d, _ in ff[0][0]]),
            )

    chunks = []
    with open(index, encoding="latin-1") as f:
        n = 0
        for l in f:
            n += 1
            chunk = l.rstrip("\n")
            if " " in chunk or "/" not in chunk:
                err(f"{index}:{n}: bad format:", chunk)
                continue
            ctag = chunk.split("/")[-1]
            ffc = ctags.get(ctag)
            if ffc is not None:
                n = 0
                for ff, cc in ffc:
                    n += sum([len(c) for c in cc])
                    cc[ff[3].index(ctag)].append(chunk)
                if n == 0:
                    # Only append the first time we see a chunk in this file. Other chunks will be added later.
                    chunks.append(ffc)

    for t, ffc in ctags.items():
        n = 0
        for ff, cc in ffc:
            dt, fname, t, ct, e = ff
            for d, t in dt:
                for ic, c in enumerate(cc):
                    if len(c) == 0:
                        err(f"file {d}/{fname} chunk {ct[ic]} not found")
                    elif len(c) > 1:
                        info(
                            f"multiple copies of file {d}/{fname} chunk {ct[ic]}:",
                            " ".join(c),
                        )
                    n += len(c)
        if n == 0 and args.missing_chunks:
            chunks.append(ffc)

    chunks += empty

    return chunks


def process():
    parse_args()
    idir = Path(args.dir)
    dirs = lsdirs(idir / "dir-metadata-index.txt")

    if args.list_directories:
        for d, t in dirs:
            if args.tags:
                print(d + "\t" + t)
            else:
                print(d)

    if args.list_files:
        files = lsfiles(idir / "file-metadata-index.txt", dirs)
        for dt, f, t, c, e in files:
            for d, _ in dt:
                if args.tags:
                    print(d + "/" + f + "\t" + t)
                else:
                    print(d + "/" + f)

    if args.list_chunks:
        files = lsfiles(idir / "file-metadata-index.txt", dirs)
        chunks = lschunks(idir / "storage-chunk-index.txt", files)
        for ffc in chunks:
            for ff, cc in ffc:
                dt, f, t, c, e = ff
                for d, _ in dt:
                    if args.tags:
                        print(
                            d
                            + "/"
                            + f
                            + "\t"
                            + " ".join(c)
                            + "\t"
                            + " ".join(
                                [
                                    str(idir / chunk[0]) if len(chunk) > 0 else "-"
                                    for chunk in cc
                                ]
                                if sum([len(chunk) for chunk in cc]) > 0
                                else []
                            )
                        )
                    else:
                        print(
                            d
                            + "/"
                            + f
                            + "\t"
                            + " ".join(
                                [
                                    str(idir / chunk[0]) if len(chunk) > 0 else "-"
                                    for chunk in cc
                                ]
                                if sum([len(chunk) for chunk in cc]) > 0
                                else []
                            )
                        )


exit(process())
